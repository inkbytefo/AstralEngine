#version 450

// Image Processing Compute Shader
// Author: inkbytefo
// Project: AstralEngine

// Constants
const float PI = 3.14159265359;

// Workgroup size
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Image processing operations
const int OP_NONE = 0;
const int OP_BLUR = 1;
const int OP_SHARPEN = 2;
const int OP_EDGE_DETECT = 3;
const int OP_EMBOSS = 4;
const int OP_DILATE = 5;
const int OP_ERODE = 6;
const int OP_BILATERAL_FILTER = 7;
const int OP_MORPHOLOGICAL_GRADIENT = 8;

// Uniform buffer objects
layout(std140, binding = 0) uniform ImageProcessingUBO {
    int operation;
    float kernel[25]; // 5x5 kernel
    float kernelWeight;
    float sigma;       // For Gaussian blur
    float threshold;   // For edge detection
    vec2 texelSize;
    int padding[2];
} ipSettings;

// Textures
layout(binding = 0) uniform sampler2D inputTexture;
layout(binding = 1) uniform sampler2D secondaryTexture; // For some operations

// Storage images
layout(rgba32f, binding = 0) restrict uniform image2D outputImage;

// Gaussian kernel generation
float Gaussian(float x, float sigma)
{
    return exp(-(x * x) / (2.0 * sigma * sigma)) / (sqrt(2.0 * PI) * sigma);
}

// Sobel edge detection kernels
const float sobelX[9] = float[](
    -1.0, 0.0, 1.0,
    -2.0, 0.0, 2.0,
    -1.0, 0.0, 1.0
);

const float sobelY[9] = float[](
    -1.0, -2.0, -1.0,
     0.0,  0.0,  0.0,
     1.0,  2.0,  1.0
);

// Convolution operation
vec4 Convolution(sampler2D tex, vec2 uv, vec2 texelSize, float kernel[9])
{
    vec4 result = vec4(0.0);
    
    for (int i = -1; i <= 1; i++) {
        for (int j = -1; j <= 1; j++) {
            vec2 offset = vec2(float(j), float(i)) * texelSize;
            float weight = kernel[(i + 1) * 3 + (j + 1)];
            result += texture(tex, uv + offset) * weight;
        }
    }
    
    return result;
}

// 5x5 convolution for more advanced operations
vec4 Convolution5x5(sampler2D tex, vec2 uv, vec2 texelSize, float kernel[25])
{
    vec4 result = vec4(0.0);
    
    for (int i = -2; i <= 2; i++) {
        for (int j = -2; j <= 2; j++) {
            vec2 offset = vec2(float(j), float(i)) * texelSize;
            float weight = kernel[(i + 2) * 5 + (j + 2)];
            result += texture(tex, uv + offset) * weight;
        }
    }
    
    return result;
}

// Bilateral filter
vec4 BilateralFilter(sampler2D tex, vec2 uv, vec2 texelSize, float sigmaSpatial, float sigmaRange)
{
    vec4 centerColor = texture(tex, uv);
    vec4 result = vec4(0.0);
    float totalWeight = 0.0;
    
    for (int i = -2; i <= 2; i++) {
        for (int j = -2; j <= 2; j++) {
            vec2 offset = vec2(float(j), float(i)) * texelSize;
            vec4 sampleColor = texture(tex, uv + offset);
            
            // Spatial weight
            float spatialDist = length(vec2(float(i), float(j)));
            float spatialWeight = Gaussian(spatialDist, sigmaSpatial);
            
            // Range weight
            float rangeDist = length(centerColor.rgb - sampleColor.rgb);
            float rangeWeight = Gaussian(rangeDist, sigmaRange);
            
            float weight = spatialWeight * rangeWeight;
            result += sampleColor * weight;
            totalWeight += weight;
        }
    }
    
    return result / totalWeight;
}

// Morphological operations
vec4 MorphologicalOperation(sampler2D tex, vec2 uv, vec2 texelSize, int operation)
{
    vec4 result = vec4(0.0);
    
    // 3x3 neighborhood
    vec4 samples[9];
    int index = 0;
    for (int i = -1; i <= 1; i++) {
        for (int j = -1; j <= 1; j++) {
            vec2 offset = vec2(float(j), float(i)) * texelSize;
            samples[index++] = texture(tex, uv + offset);
        }
    }
    
    if (operation == OP_DILATE) {
        // Dilation: take maximum
        result = samples[0];
        for (int i = 1; i < 9; i++) {
            result = max(result, samples[i]);
        }
    } else if (operation == OP_ERODE) {
        // Erosion: take minimum
        result = samples[0];
        for (int i = 1; i < 9; i++) {
            result = min(result, samples[i]);
        }
    } else if (operation == OP_MORPHOLOGICAL_GRADIENT) {
        // Morphological gradient: dilation - erosion
        vec4 dilation = samples[0];
        vec4 erosion = samples[0];
        for (int i = 1; i < 9; i++) {
            dilation = max(dilation, samples[i]);
            erosion = min(erosion, samples[i]);
        }
        result = dilation - erosion;
    }
    
    return result;
}

// Edge detection using Sobel operator
vec4 EdgeDetection(sampler2D tex, vec2 uv, vec2 texelSize, float threshold)
{
    // Apply Sobel X and Y
    vec4 edgeX = Convolution(tex, uv, texelSize, sobelX);
    vec4 edgeY = Convolution(tex, uv, texelSize, sobelY);
    
    // Calculate magnitude
    vec4 magnitude = sqrt(edgeX * edgeX + edgeY * edgeY);
    
    // Apply threshold
    if (threshold > 0.0) {
        magnitude = step(vec4(threshold), magnitude);
    }
    
    return magnitude;
}

// Emboss effect
vec4 Emboss(sampler2D tex, vec2 uv, vec2 texelSize)
{
    const float embossKernel[9] = float[](
        -2.0, -1.0,  0.0,
        -1.0,  1.0,  1.0,
         0.0,  1.0,  2.0
    );
    
    vec4 result = Convolution(tex, uv, texelSize, embossKernel);
    result += 0.5; // Add bias to make it visible
    
    return result;
}

// Sharpen filter
vec4 Sharpen(sampler2D tex, vec2 uv, vec2 texelSize)
{
    const float sharpenKernel[9] = float[](
         0.0, -1.0,  0.0,
        -1.0,  5.0, -1.0,
         0.0, -1.0,  0.0
    );
    
    return Convolution(tex, uv, texelSize, sharpenKernel);
}

// Custom blur using provided kernel
vec4 CustomBlur(sampler2D tex, vec2 uv, vec2 texelSize)
{
    return Convolution5x5(tex, uv, texelSize, ipSettings.kernel) / ipSettings.kernelWeight;
}

// Image blending operations
vec4 BlendImages(vec4 color1, vec4 color2, int blendMode)
{
    switch (blendMode) {
        case 0: // Normal
            return color2;
        case 1: // Multiply
            return color1 * color2;
        case 2: // Screen
            return 1.0 - (1.0 - color1) * (1.0 - color2);
        case 3: // Overlay
            return mix(color1 * color2 * 2.0, 1.0 - 2.0 * (1.0 - color1) * (1.0 - color2), step(0.5, color1));
        case 4: // Soft Light
            return mix(2.0 * color1 * color2 + color1 * color1 * (1.0 - 2.0 * color2), 
                       sqrt(color1) * (2.0 * color2 - 1.0) + 2.0 * color1 * (1.0 - color2), 
                       step(0.5, color2));
        default:
            return color2;
    }
}

// Color adjustments
vec4 AdjustColor(vec4 color, float brightness, float contrast, float saturation)
{
    // Brightness
    color.rgb += brightness;
    
    // Contrast
    color.rgb = ((color.rgb - 0.5) * max(contrast, 0.0)) + 0.5;
    
    // Saturation
    float luminance = dot(color.rgb, vec3(0.2126, 0.7152, 0.0722));
    color.rgb = mix(vec3(luminance), color.rgb, max(saturation, 0.0));
    
    return color;
}

// Main image processing function
void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    vec2 uv = vec2(texelCoord) * ipSettings.texelSize;
    
    // Sample input texture
    vec4 color = texture(inputTexture, uv);
    
    // Apply selected operation
    switch (ipSettings.operation) {
        case OP_BLUR:
            color = CustomBlur(inputTexture, uv, ipSettings.texelSize);
            break;
            
        case OP_SHARPEN:
            color = Sharpen(inputTexture, uv, ipSettings.texelSize);
            break;
            
        case OP_EDGE_DETECT:
            color = EdgeDetection(inputTexture, uv, ipSettings.texelSize, ipSettings.threshold);
            break;
            
        case OP_EMBOSS:
            color = Emboss(inputTexture, uv, ipSettings.texelSize);
            break;
            
        case OP_DILATE:
            color = MorphologicalOperation(inputTexture, uv, ipSettings.texelSize, OP_DILATE);
            break;
            
        case OP_ERODE:
            color = MorphologicalOperation(inputTexture, uv, ipSettings.texelSize, OP_ERODE);
            break;
            
        case OP_BILATERAL_FILTER:
            color = BilateralFilter(inputTexture, uv, ipSettings.texelSize, ipSettings.sigma, ipSettings.sigma);
            break;
            
        case OP_MORPHOLOGICAL_GRADIENT:
            color = MorphologicalOperation(inputTexture, uv, ipSettings.texelSize, OP_MORPHOLOGICAL_GRADIENT);
            break;
            
        case OP_NONE:
        default:
            // No operation, pass through
            break;
    }
    
    // Clamp color values
    color = clamp(color, 0.0, 1.0);
    
    // Store result in output image
    imageStore(outputImage, texelCoord, color);
}
